# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Freeman-Tukey transformation on a matrix
#'
#' \code{sqrt(X) + sqrt(X + 1)}
#'
#' @param X A matrix in a shape of #genes x #samples.
#' @return A matrix in a same shape of \code{X} with freeman tukey
#' transformation performed.
#' @export
freeman_tukey_transform <- function(X) {
    .Call('_knnsmoother_freeman_tukey_transform', PACKAGE = 'knnsmoother', X)
}

#' Pair-wise euclidean distance among two matrices.
#'
#' @param Ar A matrix with samples on rows.
#' @param Br A matrix with samples on rows.
#' @return A distance matrix in a shape of nrow(\code{Ar}) x nrow(\code{Br}).
#' @references \url{http://blog.felixriedel.com/2013/05/pairwise-distances-in-r/}
#' @examples
#' x <- matrix(1:12, 3)
#' all.equal(c(as.matrix(dist(x))), c(dist_euclidean(x, x)))
#' @export
dist_euclidean <- function(Ar, Br) {
    .Call('_knnsmoother_dist_euclidean', PACKAGE = 'knnsmoother', Ar, Br)
}

#' Distance matrix
#'
#' Normalize (by median) and apply Freeman-Tukey transformation on the input
#' matrix \code{X}. Then calculate the distance matrix of samples.
#'
#' @param X A matrix in a shape of #genes x #samples.
#' @param verbose An integer to specify verbose level.
#' @return A distance matrix in a shape of #samples x #samples.
#' @export
smoother_calc_distance <- function(X, verbose = 0L) {
    .Call('_knnsmoother_smoother_calc_distance', PACKAGE = 'knnsmoother', X, verbose)
}

#' Aggregate K nearest expression profiles
#'
#' Normalize (by median) and apply Freeman-Tukey transformation on the input
#' matrix \code{X}. Then calculate the distance matrix of samples.
#'
#' @param Xr A matrix in a shape of #genes x #samples.
#' @param Dr A predefined distance matrix in a shape of #samples x #samples. If
#'   not specified, D is the distance matrix of the input \code{Xr}.
#' @param k An integer to choose \code{k} nearest samples (self-inclusive) to
#'  aggregate based on the distance matrix \code{Dr}. If \code{k} is greater than
#'  #samples, \code{k} is forced to be #samples to continue aggregation.
#' @param verbose An integer to specify verbose level.
#' @return An aggregated matrix in a same shape of \code{Xr}.
#' @export
aggregate_k_nearest <- function(Xr, Dr = matrix(), k = 2L, verbose = 0L) {
    .Call('_knnsmoother_aggregate_k_nearest', PACKAGE = 'knnsmoother', Xr, Dr, k, verbose)
}

#' Perform KNN-smoothing on UMI-filtered scRNA-seq data
#'
#' @param X A matrix in a shape of #genes x #samples.
#' @param k An integer to choose \code{k} nearest samples (self-inclusive) to
#'  aggregate based on the distance matrix \code{Dr}. If \code{k} is greater than
#'  #samples, \code{k} is forced to be #samples to continue aggregation.
#' @param verbose An integer to specify verbose level.
#' @return An aggregated matrix in a same shape of \code{X}.
#' @references  "K-nearest neighbor smoothing for high-throughput single-cell
#'   RNA-Seq data" (Florian Wagner, Yun Yan, Itai Yanai, bioRxiv 217737; doi:
#'   \url{https://doi.org/10.1101/217737}).
#' @export
knn_smoothing <- function(X, k = 5L, verbose = 0L) {
    .Call('_knnsmoother_knn_smoothing', PACKAGE = 'knnsmoother', X, k, verbose)
}

